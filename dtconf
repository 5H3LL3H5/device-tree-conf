#!/usr/bin/python3

import sys
import getopt
import time
import os
import subprocess
import shutil
import logging
import typing
import argparse
import git


class DTConf:
    """ Singleton class used to manage former global vars and argument parsing

        Allow easy implementation of "command interface"
    """

    commands = ["build", "status", "validate",
                "enable", "disable", "activate", "print"]

    products = [
        ("colibri imx6", ["0014", "0015", "0016", "0017"]),
        ("apalis imx6", ["0027", "0028", "0029", "0035"]),
        ("colibri imx7", ["0032", "0033", "0039"]),
        ("colibri imx6ull", ["0036", "0040", "0044", "0045"]),
        ("apalis imx8", ["0037", "0047", "0048", "0049", "0046"]),
        ("colibri imx8", ["0038", "0050", "0051", "0052"])
    ]

    def __init__(self):
        """ Basic initialization
        """
        self.product_id = None

        self.bootmnt = "/mnt/part"
        self.gitrepo = "/device-tree-overlays"
        self.userepo = True
        self.dogitpull = False

        # configures logging: errors and warnings on stderr, regular messages on stdout
        self.logger = logging.getLogger()

        self.logger.setLevel(logging.INFO)

        logstdout = logging.StreamHandler(sys.stdout)
        logstdout.setLevel(logging.INFO)
        logstdout.addFilter(lambda record: record.levelno <= logging.INFO)
        logstdout.setFormatter(logging.Formatter("%(message)s"))

        logstderr = logging.StreamHandler(sys.stderr)
        logstderr.setLevel(logging.WARNING)
        logstderr.setFormatter(logging.Formatter("%(message)s"))

        self.logger.addHandler(logstdout)
        self.logger.addHandler(logstderr)

    def help(self, short):

        logging.info("usage: dtconf < command > [arguments]\n")

        if short:
            logging.info("Commands:\n"
                         "\thelp\n"
                         "\tbuild\n"
                         "\tstatus\n"
                         "\tvalidate\n"
                         "\tenable\n"
                         "\tdisable\n"
                         "\tactivate\n"
                         "\tprint\n"
                         "Use help command to have a more detailed list of commands and their arguments.")
        else:
            for command in DTConf.commands:
                logging.info("\ncommand: "+command+"\n")
                parser = getattr(self, command+"_createparser")()
                parser.print_help()

    def setup(self) -> bool:
        """ Module initialization, detect module type and mounts boot partition.

            It must be called before any other function call from this module
        """

        bootpart = "/dev/disk/by-label/BOOT"

        with open("/proc/device-tree/toradex,product-id", "r") as f:
            productstr = f.readline()

        productstr = productstr[:-1]

        for product in DTConf.products:
            for productid in product[1]:
                if productid == productstr:
                    self.product_id = productid
                    logging.info(
                        "Device is "+product[0]+"("+self.product_id+")")
                    break

            if self.product_id is not None:
                break

        if self.product_id is None:
            logging.error(
                "Unknown device (check that container is running in privileged mode and with the suggested command line parameters).")
            return False

        if not os.path.ismount(self.bootmnt):
            logging.info("Mounting "+self.bootmnt)

            if not os.path.exists(self.bootmnt):
                os.mkdir(self.bootmnt)

            if subprocess.run(["mount", bootpart, self.bootmnt]).returncode != 0:
                logging.error("Failed to mount "+bootpart+" "+self.bootmnt)
                return False

        return True

    def add_repo_parms(self, parser):
        parser.add_argument("--no-git-repo", dest="norepo", help="Use an overlay that is not in the Toradex git repo",
                            action="store_true", default=False)
        parser.add_argument("--do-git-pullpull", dest="dopull", help="Pull latest version of the overlays (requires an internet connection)",
                            action="store_true", default=False)
        parser.add_argument("--git-repo", dest="gitrepo", help="path of a different git repo to be used for the overlays",
                            action="store", default=self.gitrepo)

    def process_repo_args(self, args):
        if args.norepo == True:
            self.userepo = False
        else:
            self.gitrepo = args.gitrepo
            self.dogitpull = args.dopull

    def git_checkout(self):
        repo = git.Repo(path=self.gitrepo)

        if repo.bare:
            raise Exception("git repo seem to be empty.")

        # try to find a branch matching current kernel version
        uname = subprocess.run(
            ["uname", "-r"], stdout=subprocess.PIPE)

        if uname.returncode != 0:
            raise Exception("Error executing uname")

        kernelversion = uname.stdout.decode("utf-8")

        kernelmaj, kernelmin = kernelversion.split(".")[0:2]

        headname = "toradex_"+kernelmaj+"."+kernelmin+".y"

        # update repo
        if self.dogitpull:
            repo.remote("origin").pull()

        head = next((h for h in repo.branches if h.name == headname), None)

        if head is None:
            raise Exception(
                "No branch matching current kernel version ("+kernelmaj+"."+kernelmin+")")

        head.checkout()

    def status_createparser(self) -> argparse.ArgumentParser:

        parser = argparse.ArgumentParser(prog="dtconf status",
                                         description="\tshow current state of device trees and overlays.")

        self.add_repo_parms(parser)

        return parser

    def status(self, sysargs) -> int:

        parser = self.status_createparser()

        args = parser.parse_args(sysargs)

        self.process_repo_args(args)

        self.setup()

        currentoverlays = self.get_active_overlays()[1]
        if len(currentoverlays) > 0:
            logging.info("Currently active overlays:")
            for overlay in currentoverlays:
                logging.info(overlay)
        else:
            logging.info("No active overlays")

        logging.info("Available base device trees:")

        searchpath = self.get_dt_search_path()

        for path in os.listdir(searchpath):
            if (path.endswith(".dtb")):
                if os.path.isfile(searchpath + path):
                    logging.info("\t"+path)

        if not self.userepo:
            return 0

        self.git_checkout()

        logging.info("Available overlays for running kernel:")

        overlayspath = os.path.join(self.gitrepo, "overlays")

        for path in os.listdir(overlayspath):
            if (path.endswith(".dts")):
                if os.path.isfile(os.path.join(overlayspath, path)):
                    logging.info("\t"+path)

        return 0

    def build_createparser(self) -> argparse.ArgumentParser:

        parser = argparse.ArgumentParser(prog="dtconf build",
                                         description="compiles device tree overlays from source (dts) to binary (dtb) format.")

        self.add_repo_parms(parser)

        parser.add_argument("filename", help="dts file(s) to be compiled", action="store",
                            nargs="+", type=str)
        parser.add_argument("-o", "--output-path", help="output path for the compiled file(s)",
                            dest="outputpath", action="store", type=str, default=None)

        return parser

    def build(self, sysargs) -> int:

        parser = self.build_createparser()

        args = parser.parse_args(sysargs)

        self.process_repo_args(args)

        self.setup()

        if self.userepo:
            self.git_checkout()

        for overlay in args.filename:
            overlaypath = overlay

            if self.userepo:
                overlaypath = os.path.join(self.gitrepo, "overlays")
                overlaypath = os.path.join(overlaypath, overlay)

            self.build_dtb(overlaypath, args.outputpath)

        return 0

    def validate_createparser(self) -> argparse.ArgumentParser:

        parser = argparse.ArgumentParser(prog="dtconf validate",
                                         description="\tvalidate binary device tree overlays.")

        parser.add_argument("filename", help="dtb file(s) to be validated", action="store",
                            nargs="+", type=str)
        parser.add_argument("-c", "--current-device-tree", help="currently active device tree",
                            dest="currentdevicetree", action="store", type=str, default=None)

        return parser

    def validate(self, sysargs) -> int:

        retval = 0

        parser = self.validate_createparser()

        args = parser.parse_args(sysargs)

        self.setup()

        for overlay in args.filename:
            overlaypath = overlay

            if self.userepo:
                overlaypath = os.path.join(self.gitrepo, "overlays")
                overlaypath = os.path.join(overlaypath, overlay)

            if not self.validate_dtb(overlaypath, args.currentdevicetree):
                logging.error("Validation of "+overlay+" failed.")
                retval = 1
            else:
                logging.info("Validation of "+overlay+" completed.")

        return retval

    def enable_createparser(self) -> argparse.ArgumentParser:

        parser = argparse.ArgumentParser(prog="dtconf enable",
                                         description="\tenable a binary device tree overlay.")

        parser.add_argument("filename", help="dtb file(s) to be enabled", action="store",
                            nargs="+", type=str)

        return parser

    def enable(self, sysargs) -> int:

        parser = self.enable_createparser()

        args = parser.parse_args(sysargs)

        self.setup()

        for overlay in args.filename:
            self.enable_overlay(overlay)
            logging.info("Overlay file " + overlay + " has been enabled")

    def disable_createparser(self) -> argparse.ArgumentParser:

        parser = argparse.ArgumentParser(prog="dtconf disable",
                                         description="\tdisable binary device tree overlays")

        parser.add_argument("filename", help="dtb file(s) to be disabled", action="store",
                            nargs="+", type=str)
        parser.add_argument("--all", help="disables all overlay", action="store_true",
                            default=False)
        return parser

    def disable(self, sysargs) -> int:

        parser = self.disable_createparser()

        args = parser.parse_args(sysargs)

        self.setup()

        if args.all:
            self.disable_all_overlays()
            logging.info("All active overlays have been disabled.")
        else:

            for overlay in args.filename:
                self.disable_overlay(overlay)
                logging.info("Overlay file " + overlay + " has been disabled")

    def activate_createparser(self) -> argparse.ArgumentParser:
        parser = argparse.ArgumentParser(prog="dtconf activate",
                                         description='Build, validate and enable a source device tree overlay (dts).')

        parser.add_argument("filename", help="dts file(s) to be validated", action="store",
                            nargs="+", type=str)
        parser.add_argument("-c", "--current-device-tree", help="currently active device tree",
                            dest="currentdevicetree", action="store", type=str, default=None)

        return parser

    def activate(self, sysargs) -> int:

        parser = self.activate_createparser()

        args = parser.parse_args(sysargs)

        self.setup()

        self.activate_overlays(args.filename, args.currentdevicetree)

    def print_createparser(self) -> argparse.ArgumentParser:

        parser = argparse.ArgumentParser(prog="dtconf print",
                                         description='Dumps binary device-tree overlays in human readable format.')

        parser.add_argument("filename", help="dtb file(s) to be dumped", action="store",
                            nargs="+", type=str)

        parser.add_argument("-b", "--bare-format", help="currently active device tree",
                            dest="bare", action="store_true", default=False)

        return parser

    def print(self, sysargs) -> int:

        parser = self.print_createparser()

        args = parser.parse_args(sysargs)

        self.setup()

        for overlay in args.filename:

            if not os.path.isfile(overlay):
                overlay = os.path.join(self.get_dt_search_path(), overlay)

            if not args.bare:
                logging.info("++ Dumping: " + overlay)

            logging.info(self.dump_dtb(overlay))

        return 0

    def build_dtb(self, filename, outputpath=None) -> str:
        """ Compile a dtbs file into dtb or dtbo output

            Args:
                filename (str) - path of source file
                outputpath (str) - output file name/folder, if None then extension
                    is appended to source file name, if it's a folder file with dtb/dtbo
                    extension is created

            Returns:
                name of generated file

            Raises:
                Exception: invalid file name or build errors
        """

        if not os.path.isfile(filename):
            raise Exception("Invalid filename")

        ext = ".dtb"

        with open(filename, "r") as f:
            for line in f:
                if "fragment@0" in line:
                    ext = ".dtbo"
                    break

        if outputpath is None:
            outputpath = "./"+os.path.basename(filename)+ext

        if os.path.isdir(outputpath):
            outputpath = os.path.join(
                outputpath, os.path.basename(filename)+ext)

        dtcprocess = subprocess.run(
            ["dtc", "-@", "-I", "dts", "-O", "dtb", "-o", outputpath, filename], stderr=subprocess.PIPE)

        if dtcprocess.returncode != 0:
            raise Exception("Failed to build device tree.\n" +
                            dtcprocess.stderr.decode("utf-8"))

        logging.info("Successfully built device tree")
        return outputpath

    def get_dt_search_path(self) -> str:
        """ Return folder where device trees are stored

            Functions checks loader enviroment to find the right ostree
            layer where currently usable device trees are stored.

            Returns:
                str - folder path (with final /)
        """
        searchpath = None

        with open("/boot/loader/uEnv.txt", "r") as f:
            for line in f:
                if line.startswith("fdt_path="):
                    searchpath = line[len("fdt_path="):]
                    searchpath = searchpath.rstrip()
                    break

        if searchpath is not None:
            searchpath = "/boot"+searchpath

        return searchpath

    def get_active_dt_path(self, activedt) -> str:
        """ Returns full path of currently active device tree

            Args:
                activedt (str): device tree name (required for imx7)

            Returns:
                full path of device tree file or None if no dt is found

            Raises: Exception if multiple device trees are found in the folder and
                activedt arg is None
        """

        activedtpath = None
        searchpath = self.get_dt_search_path()

        if activedt is not None:
            activedtpath = searchpath + activedt
        else:

            with open('/proc/device-tree/model', 'r') as f:
                model = f.read()

            # remove terminating null
            model = model[:len(model)-1]

            for path in os.listdir(searchpath):
                if (path.endswith(".dtb")):

                    dtbpath = searchpath + path
                    if os.path.isfile(dtbpath):

                        dtbdump = self.dump_dtb(dtbpath)

                        tag = "model = "

                        index = dtbdump.find(tag)

                        if index == -1:
                            continue

                        modelstr = dtbdump[index+len(tag)+1:]
                        modelstr = modelstr[:modelstr.find('"')]
                        modelstr = modelstr.replace("\\0", "\x00")

                        if model == modelstr:
                            if activedtpath is None:
                                activedtpath = dtbpath
                            else:
                                raise Exception(
                                    "Multiple device trees have the same model string, please select one with the -c command line parameter.")

        if activedtpath is None:
            raise Exception(
                "Cannot find a valid base binary device tree, please provide one with -c command line parameter.")

        return activedtpath

    def validate_dtb(self, filename, activedt) -> bool:
        """ Verifies that a compiled overlay is valid for the base device tree

            Args:
                filename (str) - path of overlay that needs to be validated
                activedt (str) - currently active device tree (needed on imx7)

            Returns:
                bool: True for valid overlay

            Raises:
                Exception - No active device tree
        """
        activedtpath = self.get_active_dt_path(activedt)

        if activedtpath is None:
            raise Exception("Could not find active device tree.")

        fdtoverlay = subprocess.run(["fdtoverlay", "-i", activedtpath, "-o", "/tmp/" +
                                     os.path.basename(activedtpath)+".tmp", filename], stderr=subprocess.PIPE)

        if fdtoverlay.returncode != 0:
            logging.error(fdtoverlay.stderr.decode("utf-8"))
            return False

        return True

    def get_overlays_file_path(self) -> str:
        """ Returns the path where overlay configuration file and binary overlays are stored

            Returns:
                str - folder path (without final /)
        """

        return self.bootmnt + "/overlays.txt"

    def get_active_overlays(self) -> typing.Tuple[typing.List[str], typing.List[str]]:
        """ Returns a list of overlay file configuration (without overlays line) and currently active overlays

            Returns:
                Tuple[List,List] - list of overlay file rows (excluding overlays)
                    and list of str objects with overlay filenames
        """

        overlaysfilepath = self.get_overlays_file_path()

        overlayslines = []
        currentoverlays = []

        if os.path.exists(overlaysfilepath):
            with open(overlaysfilepath, "r") as f:
                overlayslines = f.readlines()

        for line in overlayslines:
            if line.startswith("fdt_overlays="):
                overlayslines.remove(line)
                line = line[len("fdt_overlays="):].strip()
                currentoverlays = line.split()

        return overlayslines, currentoverlays

    def enable_overlay(self, overlay):
        """ Applies overlays to boot configuration

        Copy passed overlay files to boot partition and adds them to the list
        of overlays that are loaded at boot

        Args:
            overlays (str) - overlay file name
        """

        if not os.path.exists(overlay):
            raise Exception(overlay+" doesn't exists.")

        shutil.copy(overlay, self.bootmnt)
        overlayname = os.path.basename(overlay)

        overlayslines, currentoverlays = self.get_active_overlays()

        if overlayname not in currentoverlays:
            currentoverlays.append(overlayname)
        else:
            logging.info("Overlay "+overlay+" is already enabled")
            return

        overlaysline = "fdt_overlays="

        for currentoverlay in currentoverlays:
            overlaysline += currentoverlay+" "

        overlayslines.append(overlaysline.strip()+"\n")

        with open(self.get_overlays_file_path(), "w") as f:
            f.writelines(overlayslines)

    def disable_overlay(self, overlay):
        """ Applies overlays to boot configuration

        Remove an overlay from the list of those that are loaded at boot time

        Args:
            overlays (str) - overlay file name
        """

        overlayname = os.path.basename(overlay)

        overlayslines = []
        overlayslines, currentoverlays = self.get_active_overlays()

        if overlayname not in currentoverlays:
            logging.info("Overlay "+overlay+" is currently not enabled")
            return

        overlaysline = "fdt_overlays="

        for currentoverlay in currentoverlays:
            if overlayname != currentoverlay:
                overlaysline += currentoverlay+" "

        overlayslines.append(overlaysline.strip()+"\n")

        with open(self.get_overlays_file_path(), "w") as f:
            f.writelines(overlayslines)

    def disable_all_overlays(self):
        """ Applies overlays to boot configuration

        Remove all overlays that are configured at boot
        """

        overlayslines = self.get_active_overlays()[0]

        with open(self.get_overlays_file_path(), "w") as f:
            f.writelines(overlayslines)

    def activate_overlays(self, overlays, activedt):
        """ Builds, validates and applies multiple overlays

            Operation will stop if build/validation of one of the overlays fails

            Args:
                overlays (list) - list of dts files that should be used as overlays
                activedt (str) - current device tree, in None it will be auto-detected
        """

        builtoverlays = []

        for overlay in overlays:

            overlaypath = overlay

            if self.userepo:
                overlaypath = os.path.join(self.gitrepo, "overlays")
                overlaypath = os.path.join(overlaypath, overlay)

            logging.info("Building "+overlay)
            outfile = self.build_dtb(overlaypath, None)
            logging.info("Validating "+overlay)

            if not self.validate_dtb(outfile, activedt):
                raise Exception("Invalid overlay")

            logging.info("Overlay is valid.")
            builtoverlays.append(outfile)

        for builtoverlay in builtoverlays:
            self.enable_overlay(builtoverlay)

    def dump_dtb(self, filename) -> str:
        """ Dumps a dtb binary in dts-like format

            The generated output may not be2020 valid dts, this function
            can be used for debugging/validation only

            Args:
                filename(str) - path of dtb file

            Returns:
                dump of dtb contents in human-redable format
        """

        if not os.path.exists(filename):
            raise Exception("Invalid filename")

        fdtdumpprocess = subprocess.run(
            ["dtc", "-I", "dtb", "-O", "dts", "-q", filename], stdout=subprocess.PIPE)

        if fdtdumpprocess.returncode != 0:
            raise Exception("Error executing fdtdump")

        return fdtdumpprocess.stdout.decode("utf-8")

    def run(self, args) -> int:
        """ Processes command line arguments and return an exit code
        """

        if len(sys.argv) <= 1:
            self.help(True)
            return 0

        # command line args
        parser = argparse.ArgumentParser(
            description="Device tree overlays tool", usage="dtconf <command> [<args>]")

        parser.add_argument("command", help="subcommand to run")

        args = parser.parse_args(sys.argv[1:2])

        if args.command == "help":
            self.help(False)
            return 0

        if args.command not in DTConf.commands:
            logging.error("Unrecognized command.")
            self.help(True)
            return -1

        # invoke command using its name (we are lazy)
        return getattr(self, args.command)(sys.argv[2:])


if __name__ == "__main__":

    try:
        dtconf = DTConf()

        sys.exit(dtconf.run(sys.argv))

    except Exception as e:
        logging.error(str(e))
        sys.exit(-1)

    # initialization steps required fo all the different operations

    # if not init():
    #     logging.error(
    #         "Initialization failed.")
    #     sys.exit(-1)

    # # perform operations, depending on the command required
    # cmd = sys.argv[1]

    # if len(sys.argv) > 2:
    #     args = sys.argv[2:]
    # else:
    #     args = []

    # try:
    #     if cmd == "-h" or cmd == "--help":
    #         long_usage()

    #     elif cmd == "-s" or cmd == "--status":

    #     elif cmd == "-p" or cmd == "--print":
    #         if len(args) == 0:
    #             raise Exception("No file name specified.")

    #         for dtbfile in args:
    #             logging.info(dump_dtb(dtbfile))

    #     elif cmd == "-a" or cmd == "--activate":
    #         if len(args) == 0:
    #             raise Exception("No file name specified.")

    #         filenames = []
    #         dtname = None

    #         nextisdt = False

    #         for arg in args:

    #             if nextisdt:
    #                 dtname = arg
    #             else:
    #                 if arg == "-c":
    #                     nextisdt = True
    #                 else:
    #                     filenames.append(arg)

    #         if nextisdt and dtname is None:
    #             raise Exception(
    #                 "A valid device-tree filename must be specified for -c parameter")

    #         activate_overlays(filenames, dtname)
    #         logging.info(
    #             "A reboot is necessary for changes to take effect")

    #     elif cmd == "-b" or cmd == "--build":
    #         if len(args) == 0:
    #             raise Exception("No file name specified")

    #     elif cmd == "-e" or cmd == "--enable":
    #         if len(args) == 0:
    #             raise Exception("No file name specified")

    #         for dtbfile in args:
    #             enable_overlay(dtbfile)
    #             logging.info("Overlay file "+dtbfile +
    #                          " has been enabled")
    #         logging.info(
    #             "A reboot is necessary for changes to take effect")

    #     elif cmd == "-d" or cmd == "--disable":
    #         if len(args) == 0:
    #             raise Exception("No file name specified")

    #         for dtbfile in args:
    #             if dtbfile == "all":
    #                 disable_all_overlays()
    #             else:
    #                 disable_overlay(dtbfile)

    #             logging.info("Overlay file "+dtbfile +
    #                          " has been disabled")
    #         logging.info(
    #             "A reboot is necessary for changes to take effect")

    #     elif cmd == "-v" or cmd == "--verify":
    #         filenames = []
    #         dtname = None

    #         nextisdt = False

    #         for arg in args:

    #             if nextisdt:
    #                 dtname = arg
    #             else:
    #                 if arg == "-c":
    #                     nextisdt = True
    #                 else:
    #                     filenames.append(arg)

    #             if nextisdt and dtname is None:
    #                 raise Exception(
    #                     "A valid device-tree filename must be specified for -c parameter")

    #         for dtofile in filenames:
    #             validate_dtb(dtofile, dtname)
    #             logging.info("Overlay file "+dtofile+" has been validated")

    #     else:
    #         raise Exception("Invalid command line argument "+arg)
